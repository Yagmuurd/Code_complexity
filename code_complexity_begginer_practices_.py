# -*- coding: utf-8 -*-
"""Code_complexity_begginer_practices .ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1wnaLCrL19lCzInQi9O0ZOttVuAbUnV64

Algorithm: A sequential and logical expression of all the operations needed to  solve a particular problem.


Code complexity: Working on what we can do better
"""

def multiplication(x,y):
  return x * y

# this is an algorithm

multiplication(10, 15000)

# Code to add all numbers from 1 to n

def square_sum(n):
  sum_variable = 0
  for x in range(1, n+1):
    sum_variable += x ** 2
  return sum_variable

square_sum(3)

def square_sum2(n):
  return n * (n + 1) * (2 * n + 1) // 6

# This is more acceptable because it is simpler with fewer lines.
square_sum2(3)

# Commented out IPython magic to ensure Python compatibility.
# less code complexity is usually the better which is the the faster algorithm 

# let's try a feature that only works in jupyter to test this

# %timeit square_sum(3)

# Commented out IPython magic to ensure Python compatibility.
# %timeit square_sum2(3)

# O(1) ie Constant - works independently from the input size. If it was O(10000) output would still not change.

def contant_big_o(list):
  print(list[0])

contant_big_o([1,2,3])
contant_big_o([1,2,3,4,5,6,7,8,9,10])

# We have produced an output independent of the input. So this constant became a value.
# We have produced the best case, that is omega.

# O(n) linear, that is, the output will be given at the rate of input, they are directly proportional.

def linear_big_o(list):
  for value in list:
    print(value)
linear_big_o([1,2,3,4])

# O(n^2), nested loop is created. There are 2 nested loops in this one.

def find_duplicates(list):
  for i in range(len(list)):
    for j in range(i+1, len(list)):
      if list[i] == list[j]:
        return True
  return False

find_duplicates([1,2,3,4,5,6,6])

# O(n^3) Cubic, again a nested loop is formed. There are 3 nested loops this time.

def cubic_big_o(list):
  for item_1 in list:
    for item_2 in list:
      for item_3 in list:
        print(item_1, item_2, item_3)

cubic_big_o([1,2,3])

# In other words, as you use the for loop, the work becomes more complex and the problem occurs. For this reason, we should use as few for loops as possible.

def linear_big_o(liste):
  for value in liste:
    print(value)
  for value in liste:
    print(value)

linear_big_o([1,2,3,4]) 

# Remember: there is no such thing as a coefficient in the big o notation, so O(n) + O(n) = O(n) but no O(2n). 2 is called insignificant notation.